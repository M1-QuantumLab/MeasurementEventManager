#! python
'''
Start up a MeasurementEventManager instance with the specified sockets.
'''

import itertools
import logging
from multiprocessing import Process
import time
import zmq

import measurement_event_manager as mem
import measurement_event_manager.util.logger as mem_logging


###############################################################################
## Initialize logging
###############################################################################

logger = mem_logging.quick_config(
                        logging.getLogger('MeasurementEventManager'),
                        console_log_level=logging.INFO,
                        file_log_level=logging.DEBUG,
                        )
logger.debug('Logging initialized.')


###############################################################################
## Initialize ZMQ messaging
###############################################################################

GUIDE_PROTOCOL = "MEM-GR/0.1"
GUIDE_TIMEOUT = 2500 # in ms
GUIDE_ENDPOINT = 'tcp://*:5555'

MEAS_PROTOCOL = 'MEM-MS/0.1'
MEAS_ENDPOINT = 'tcp://*:5556'
MEAS_SPAWN_ENDPOINT = 'tcp://localhost:5556'


## Create ZMQ context - once for the whole script
context = zmq.Context()

## Set up guide response socket
guide_socket = context.socket(zmq.REP)
guide_socket.bind(GUIDE_ENDPOINT)
logger.debug('Guide response socket initialized.')

## Set up measurement controller response socket
meas_socket = context.socket(zmq.REP)
meas_socket.bind(MEAS_ENDPOINT)
logger.debug('Measurement controller response socket initialized.')

## Initialize poller
poller = zmq.Poller()
poller.register(guide_socket, zmq.POLLIN)
poller.register(meas_socket, zmq.POLLIN)


###############################################################################
## Main event loop
###############################################################################

logger.info('Setup complete; listening for messages.')

for server_tick in itertools.count():
    
    logger.debug('Server tick {}'.format(server_tick))

    ## Get socket polls
    ## These will be resolved in the order below on each tick
    all_sockets = dict(poller.poll())


    ## Guide request
    ################

    if all_sockets.get(guide_socket, None) == zmq.POLLIN:
        logger.debug('Guide message polled.')
        
        ## Process received message
        request = guide_socket.recv_multipart()

        ## Identify request protocol
        req_protocol = request[0]
        ## Make sure we have the correct protocol
        if not (req_protocol == GUIDE_PROTOCOL):
            logger.error('Unrecognized protocol {}'.format(req_protocol))
            guide_socket.send_multipart([GUIDE_PROTOCOL.encode(), b'ERR',])
        
        ## Unpack remaining content
        req_type = request[1]
        req_content = request[2:]

        ## Check request type and parse content accordingly
        if req_type == 'IDN':
            logger.info('Identifying to client')
            guide_socket.send_multipart([GUIDE_PROTOCOL.encode(),
                                b'IDN',
                                'MeasurementEventManager at {}'.format(
                                                    GUIDE_ENDPOINT).encode()])
            logger.debug('Response sent.')
        elif req_type == 'ADD':
            logger.info('ADD requested; running next measurement.')
            ## Run measurement using MeasurementController
            ## TODO this needs to be replaced by the proper queuing system
            Process(target=mem.MeasurementController,
                    args=(MEAS_SPAWN_ENDPOINT,),
                   ).start()
            ## Send response
            guide_socket.send_multipart([GUIDE_PROTOCOL.encode(),
                                b'ADD',
                                'foo'])
            logger.info('Response sent')
        else:
            logger.warning('Unknown request type: {}'.format(req_type))
            guide_socket.send_multipart([GUIDE_PROTOCOL.encode(),
                                b'ERR',])
            logger.info('Response sent.')


    ## Measurement request
    ######################

    if all_sockets.get(meas_socket, None) == zmq.POLLIN:
        logger.debug('Measurement message polled.')

        ## Process received message
        request = meas_socket.recv_multipart()

        ## Identify request protocol
        req_protocol = request[0]
        ## Make sure we have the correct protocol
        if not (req_protocol == MEAS_PROTOCOL):
            logger.error('Unrecognized protocol {}'.format(req_protocol))
            meas_socket.send_multipart([MEAS_PROTOCOL.encode(), b'ERR',])

        ## Unpack remaining content
        req_type = request[1]
        req_content = request[2:]

        ## Check request type and parse content accordingly
        if req_type == 'START':
            logger.info('Measurement START received; confirming...')
            meas_socket.send_multipart([MEAS_PROTOCOL.encode(), b'ACK',])
        elif req_type == 'END':
            logger.info('Measurement END received; confirming...')
            meas_socket.send_multipart([MEAS_PROTOCOL.encode(), b'ACK',])
        logger.info('Confirmation sent.')

    ## Main event loop end
